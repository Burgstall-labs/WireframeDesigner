<!DOCTYPE html>
<html>
<head>
<title>Wireframe Animation Designer (GIF)</title>
<style>
body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
#container { position: relative; }
#controls {
position: absolute;
top: 10px;
left: 10px;
background: rgba(255,255,255,0.8);
padding: 15px;
border-radius: 5px;
max-width: 300px;
max-height: 90vh;
overflow-y: auto;
z-index: 10; /* Ensure controls are on top */
}
label, input, button, select {
display: block;
margin: 8px 0;
width: 100%;
box-sizing: border-box; /* Include padding/border in width */
}
button {
background: #4CAF50;
color: white;
border: none;
padding: 10px;
cursor: pointer;
border-radius: 3px;
}
button:hover {
background: #45a049;
}
.row {
display: flex;
gap: 10px;
}
.row label, .row input, .row select {
width: auto;
flex: 1;
}
.checkbox-row {
display: flex;
align-items: center;
}
.checkbox-row input {
width: auto;
margin-right: 10px;
}
#preview {
display: none;
position: absolute;
top: 10px;
right: 10px;
background: rgba(255,255,255,0.9);
padding: 15px;
border-radius: 5px;
z-index: 10; /* Ensure preview is on top */
border: 1px solid #ccc;
text-align: center;
}
#preview img {
max-width: 300px;
max-height: 300px;
display: block;
margin: 0 auto 10px auto;
border: 1px solid #eee;
}
#progressBar {
width: 100%;
background-color: #ddd;
height: 20px;
margin-top: 10px;
border-radius: 3px;
overflow: hidden;
}
#progressFill {
height: 100%;
background-color: #4CAF50;
width: 0%;
transition: width 0.1s;
text-align: center;
color: white;
line-height: 20px;
font-size: 12px;
}
.info {
font-size: 0.8em;
color: #555;
margin-top: 15px;
border-top: 1px solid #eee;
padding-top: 10px;
}
</style>
</head>
<body>
<div id="container">
<div id="controls">
<h2>Wireframe Designer</h2>

      
<label>Shape:</label>
  <select id="shape">
    <option value="cube">Cube</option>
    <option value="sphere">Sphere</option>
    <option value="cylinder">Cylinder</option>
    <option value="cone">Cone</option>
    <option value="torus">Torus</option>
  </select>

  <div class="row">
    <div>
      <label>Width:</label>
      <input type="number" id="width" value="2" min="0.1" step="0.1">
    </div>
    <div>
      <label>Height:</label>
      <input type="number" id="height" value="2" min="0.1" step="0.1">
    </div>
    <div>
      <label>Depth:</label>
      <input type="number" id="depth" value="2" min="0.1" step="0.1">
    </div>
  </div>

  <label>Background Color:</label>
  <input type="color" id="bgColor" value="#000000">

  <label>Wireframe Color:</label>
  <input type="color" id="wireColor" value="#00ff00">

  <div class="checkbox-row">
    <input type="checkbox" id="edgesOnly" checked>
    <label for="edgesOnly">Edges Only (faster)</label>
  </div>

  <div class="checkbox-row">
    <input type="checkbox" id="showFaces">
    <label for="showFaces">Show Faces</label>
  </div>

  <label>Face Color:</label>
  <input type="color" id="faceColor" value="#4444ff">

  <label>Face Opacity:</label>
  <input type="range" id="faceOpacity" min="0" max="1" step="0.1" value="0.5">

  <label>Output Resolution:</label>
  <div class="row">
    <div>
      <label>Width:</label>
      <input type="number" id="outputWidth" value="400" min="100" step="1">
    </div>
    <div>
      <label>Height:</label>
      <input type="number" id="outputHeight" value="300" min="100" step="1">
    </div>
  </div>

  <div class="row">
    <div>
      <label>Start Angle X:</label>
      <input type="number" id="startAngleX" value="0" min="0" max="360" step="5">
    </div>
    <div>
      <label>End Angle X:</label>
      <input type="number" id="endAngleX" value="360" min="0" max="360" step="5">
    </div>
  </div>

  <div class="row">
    <div>
      <label>Start Angle Y:</label>
      <input type="number" id="startAngleY" value="0" min="0" max="360" step="5">
    </div>
    <div>
      <label>End Angle Y:</label>
      <input type="number" id="endAngleY" value="360" min="0" max="360" step="5">
    </div>
  </div>

  <label>Frame Count:</label>
  <input type="number" id="frameCount" value="30" min="2" max="180" step="1">

  <label>Frame Delay (ms):</label>
  <input type="number" id="frameDelay" value="100" min="20" max="1000" step="10">

   <label>Output Format:</label>
   <select id="outputFormat" disabled> <!-- Disabled WebP for now -->
     <option value="gif" selected>GIF</option>
     <!-- <option value="webp">WebP (Not Implemented)</option> -->
   </select>


  <button id="previewBtn">Preview Animation</button>
  <button id="renderBtn">Create GIF Animation</button>
  <div id="progressInfo">Ready</div>
  <div id="progressBar"><div id="progressFill"></div></div>

  <div class="info">
      <strong>Note:</strong> If GIF creation fails, ensure you are running this page from a local web server (e.g., Python's `http.server` or VS Code Live Server), not directly via a `file:///` URL. This is needed for the GIF worker script to load correctly.
  </div>
</div>

<div id="preview">
  <h3>Animation Preview</h3>
  <img id="previewImage" src="" alt="Animation preview">
  <button id="downloadBtn">Download GIF</button>
  <button id="closePreviewBtn">Close</button>
</div>

</div>
<!-- Make sure THREE.js is loaded before gif.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- Load gif.js library -->
<script src="gif.js"></script>
<script>
// --- Setup elements ---
const container = document.getElementById('container');
const controlsPanel = document.getElementById('controls'); // Reference to controls panel

// --- Input Elements ---
const shapeSelect = document.getElementById('shape');
const widthInput = document.getElementById('width');
const heightInput = document.getElementById('height');
const depthInput = document.getElementById('depth');
const bgColorInput = document.getElementById('bgColor');
const wireColorInput = document.getElementById('wireColor');
const edgesOnlyCheckbox = document.getElementById('edgesOnly');
const showFacesCheckbox = document.getElementById('showFaces');
const faceColorInput = document.getElementById('faceColor');
const faceOpacityInput = document.getElementById('faceOpacity');
const outputWidthInput = document.getElementById('outputWidth');
const outputHeightInput = document.getElementById('outputHeight');
const startAngleXInput = document.getElementById('startAngleX');
const endAngleXInput = document.getElementById('endAngleX');
const startAngleYInput = document.getElementById('startAngleY');
const endAngleYInput = document.getElementById('endAngleY');
const frameCountInput = document.getElementById('frameCount');
const outputFormatSelect = document.getElementById('outputFormat');
const frameDelayInput = document.getElementById('frameDelay');

// --- Button/Display Elements ---
const previewBtn = document.getElementById('previewBtn');
const renderBtn = document.getElementById('renderBtn');
const progressInfo = document.getElementById('progressInfo');
const progressFill = document.getElementById('progressFill');
const previewDiv = document.getElementById('preview');
const previewImage = document.getElementById('previewImage');
const closePreviewBtn = document.getElementById('closePreviewBtn');
const downloadBtn = document.getElementById('downloadBtn');

// --- THREE.js Setup ---
let renderer, scene, camera;
let wireframeMesh, faceMesh, edges;
let isAnimatingPreview = false;
let previewAnimationId;
let capturedFrames = [];
let isRendering = false;

function initScene() {
renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

container.appendChild(renderer.domElement);
renderer.setSize(window.innerWidth, window.innerHeight);

camera.position.z = 5;

const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(1, 1, 1);
scene.add(directionalLight);

createGeometryAndUpdateMeshes();
updateColors(); // Initial color update

// --- Event Listeners ---
window.addEventListener('resize', onWindowResize);
shapeSelect.addEventListener('change', createGeometryAndUpdateMeshes);
widthInput.addEventListener('change', createGeometryAndUpdateMeshes);
heightInput.addEventListener('change', createGeometryAndUpdateMeshes);
depthInput.addEventListener('change', createGeometryAndUpdateMeshes);
bgColorInput.addEventListener('change', updateColors);
wireColorInput.addEventListener('change', updateColors);
faceColorInput.addEventListener('change', updateColors);
faceOpacityInput.addEventListener('input', updateColors); // Use 'input' for range sliders
edgesOnlyCheckbox.addEventListener('change', updateMeshVisibility);
showFacesCheckbox.addEventListener('change', updateMeshVisibility);
previewBtn.addEventListener('click', togglePreviewAnimation);
renderBtn.addEventListener('click', startRenderAnimation);
closePreviewBtn.addEventListener('click', closePreview);
downloadBtn.addEventListener('click', downloadAnimation);

// Initial render
animate();
}

function createGeometryAndUpdateMeshes() {
if (isRendering) return; // Don't change geometry while rendering
// Stop preview if running
if (isAnimatingPreview) {
togglePreviewAnimation();
}

// Clear existing meshes from the scene first
if (wireframeMesh) scene.remove(wireframeMesh);
if (faceMesh) scene.remove(faceMesh);
if (edges) scene.remove(edges);

const shape = shapeSelect.value;
const width = Math.max(0.1, parseFloat(widthInput.value));
const height = Math.max(0.1, parseFloat(heightInput.value));
const depth = Math.max(0.1, parseFloat(depthInput.value));

let geometry;
const segments = 32; // Increase for smoother sphere/cylinder etc.

switch(shape) {
case 'sphere':
geometry = new THREE.SphereGeometry(width / 2, segments, Math.max(3, Math.round(segments/2)));
break;
case 'cylinder':
geometry = new THREE.CylinderGeometry(width / 2, width / 2, height, segments);
break;
case 'cone':
geometry = new THREE.ConeGeometry(width / 2, height, segments);
break;
case 'torus':
// Ensure tube radius is smaller than torus radius
const torusRadius = width / 2;
const tubeRadius = Math.min(torusRadius * 0.9, height / 2); // Adjust tube based on height, capped
geometry = new THREE.TorusGeometry(torusRadius, tubeRadius, Math.max(3, Math.round(segments/2)), segments);
break;
case 'cube':
default:
geometry = new THREE.BoxGeometry(width, height, depth);
}

// --- Create all potential mesh types ---
// 1. Wireframe (all lines)
const wireMaterial = new THREE.MeshBasicMaterial({
color: new THREE.Color(wireColorInput.value),
wireframe: true
});
wireframeMesh = new THREE.Mesh(geometry, wireMaterial);

// 2. Edges only
const edgesGeometry = new THREE.EdgesGeometry(geometry);
const lineMaterial = new THREE.LineBasicMaterial({ color: new THREE.Color(wireColorInput.value) });
edges = new THREE.LineSegments(edgesGeometry, lineMaterial);

// 3. Solid Faces
const faceMaterial = new THREE.MeshStandardMaterial({ // Use Standard for better lighting
color: new THREE.Color(faceColorInput.value),
transparent: true,
opacity: parseFloat(faceOpacityInput.value),
polygonOffset: true, // Prevent z-fighting with wireframe/edges
polygonOffsetFactor: 1,
polygonOffsetUnits: 1,
side: THREE.DoubleSide // Render both sides
});
faceMesh = new THREE.Mesh(geometry, faceMaterial);

// Add meshes to scene (visibility controlled separately)
scene.add(wireframeMesh);
scene.add(edges);
scene.add(faceMesh);

updateMeshVisibility(); // Set initial visibility based on checkboxes
updateColors(); // Apply current colors
}

function updateMeshVisibility() {
if (!wireframeMesh || !edges || !faceMesh) return; // Meshes not ready

const showFaces = showFacesCheckbox.checked;
const edgesOnly = edgesOnlyCheckbox.checked;

wireframeMesh.visible = !edgesOnly; // Show full wireframe only if 'edgesOnly' is OFF
edges.visible = edgesOnly; // Show edges only if 'edgesOnly' is ON
faceMesh.visible = showFaces; // Show faces based on its checkbox
}

function updateColors() {
if (isRendering) return;

scene.background = new THREE.Color(bgColorInput.value);

if (wireframeMesh) {
wireframeMesh.material.color.set(wireColorInput.value);
}
if (edges) {
edges.material.color.set(wireColorInput.value);
}
if (faceMesh) {
faceMesh.material.color.set(faceColorInput.value);
faceMesh.material.opacity = parseFloat(faceOpacityInput.value);
}
}

function onWindowResize() {
// Adjust camera aspect ratio and renderer size to fill window
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
// This is the main render loop, runs continuously
previewAnimationId = requestAnimationFrame(animate); // Keep the loop going

// Only update rotation if preview animation is NOT running
if (!isAnimatingPreview && !isRendering) {
// Optional: Add subtle idle rotation if desired
// if (edges && edges.visible) edges.rotation.y += 0.001;
// if (wireframeMesh && wireframeMesh.visible) wireframeMesh.rotation.y += 0.001;
// if (faceMesh && faceMesh.visible) faceMesh.rotation.y += 0.001;
}

renderer.render(scene, camera);
}

function togglePreviewAnimation() {
if (isRendering) return; // Don't interfere with rendering

if (isAnimatingPreview) {
// Stop preview
isAnimatingPreview = false;
previewBtn.textContent = 'Preview Animation';
// Reset rotation to initial state if desired, or leave it where it stopped
setMeshRotation(0); // Reset to frame 0 state
} else {
// Start preview
isAnimatingPreview = true;
previewBtn.textContent = 'Stop Preview';
let frame = 0;
const frameCount = parseInt(frameCountInput.value) || 30;

function animatePreviewFrame() {
if (!isAnimatingPreview) return; // Stop if toggled off

const progress = frame / frameCount;
setMeshRotation(progress);

frame = (frame + 1) % frameCount;
requestAnimationFrame(animatePreviewFrame); // Loop the preview
}
animatePreviewFrame(); // Start the preview animation loop
}
}

function setMeshRotation(progress) {
const startAngleX = (parseFloat(startAngleXInput.value) * Math.PI) / 180;
const endAngleX = (parseFloat(endAngleXInput.value) * Math.PI) / 180;
const startAngleY = (parseFloat(startAngleYInput.value) * Math.PI) / 180;
const endAngleY = (parseFloat(endAngleYInput.value) * Math.PI) / 180;

const currentAngleX = startAngleX + (endAngleX - startAngleX) * progress;
const currentAngleY = startAngleY + (endAngleY - startAngleY) * progress;

// Apply rotation to all potentially visible meshes
if (wireframeMesh) {
wireframeMesh.rotation.x = currentAngleX;
wireframeMesh.rotation.y = currentAngleY;
}
if (edges) {
edges.rotation.x = currentAngleX;
edges.rotation.y = currentAngleY;
}
if (faceMesh) {
faceMesh.rotation.x = currentAngleX;
faceMesh.rotation.y = currentAngleY;
}
}


function startRenderAnimation() {
if (isRendering) return; // Prevent multiple renders
isRendering = true;

// Stop preview if running
if (isAnimatingPreview) {
togglePreviewAnimation();
}
closePreview(); // Close any previous preview

renderBtn.disabled = true;
previewBtn.disabled = true;
controlsPanel.style.opacity = 0.7; // Dim controls during render

const frameCount = parseInt(frameCountInput.value);
const outputWidth = parseInt(outputWidthInput.value);
const outputHeight = parseInt(outputHeightInput.value);
const outputFormat = 'gif'; // Hardcoded to GIF for now
const frameDelay = parseInt(frameDelayInput.value);

capturedFrames = []; // Clear previous frames

// --- Prepare Renderer for Capture ---
const originalSize = new THREE.Vector2();
renderer.getSize(originalSize); // Store original size
const originalAspect = camera.aspect; // Store original aspect

renderer.setSize(outputWidth, outputHeight);
camera.aspect = outputWidth / outputHeight;
camera.updateProjectionMatrix();

progressInfo.textContent = 'Initializing...';
progressFill.style.width = '0%';
progressFill.textContent = '';


// --- Frame Capture Loop ---
let frame = 0;
function captureFrame() {
if (frame < frameCount) {
const progress = frame / frameCount;
setMeshRotation(progress); // Set rotation for the frame

renderer.render(scene, camera); // Render the frame

// Capture the frame data URL
try {
const frameDataUrl = renderer.domElement.toDataURL('image/png');
capturedFrames.push(frameDataUrl);
} catch (e) {
console.error("Error capturing frame:", e);
progressInfo.textContent = `Error capturing frame ${frame + 1}! Check console.`;
resetUIState();
return; // Stop rendering on capture error
}


// Update progress
const percent = Math.round(((frame + 1) / frameCount) * 100);
progressInfo.textContent = `Capturing frame ${frame + 1} / ${frameCount}`;
progressFill.style.width = `${percent}%`;
progressFill.textContent = `${percent}%`;


frame++;
// Use setTimeout for less blocking capture loop
setTimeout(captureFrame, 10); // Small delay between captures
} else {
// --- Frames Captured, Start Encoding ---
createGifAnimation(capturedFrames, frameDelay, outputWidth, outputHeight);
}
}

// Start the capture process after a brief moment to allow UI update
setTimeout(captureFrame, 50);
}

function createGifAnimation(frames, delay, width, height) {
progressInfo.textContent = 'Encoding GIF... (can take time)';
progressFill.style.width = '0%';
progressFill.textContent = '0%';

const gif = new GIF({
workers: Math.max(1, navigator.hardwareConcurrency - 1 || 2), // Use available cores (minus 1) or default to 2
quality: 10, // Lower quality means faster encoding & smaller file
width: width,
height: height,
workerScript: 'gif.worker.js',
background: bgColorInput.value // Set background color for transparency handling
});

let framesAdded = 0;
let loadErrors = 0;

frames.forEach((frameDataUrl, index) => {
const img = new Image();
img.onload = () => {
if (!isRendering) return; // Check if rendering was cancelled
gif.addFrame(img, { delay: delay });
framesAdded++;
// Only start rendering when ALL frames are successfully added
if (framesAdded === frames.length) {
progressInfo.textContent = `All frames loaded (${framesAdded}). Rendering GIF...`;
gif.render();
} else {
// Optional: update progress based on frames added
const percent = Math.round((framesAdded / frames.length) * 50); // Show load progress up to 50%
progressFill.style.width = `${percent}%`;
progressFill.textContent = `${percent}%`;
progressInfo.textContent = `Loading frame ${framesAdded}/${frames.length}`;
}
};
img.onerror = () => {
if (!isRendering) return;
console.error(`Failed to load image data for frame ${index}`);
loadErrors++;
// Decide how to handle errors - here we stop if any frame fails
progressInfo.textContent = `Error loading frame ${index+1}. Aborting.`;
resetUIState();
isRendering = false; // Force stop
};
img.src = frameDataUrl;
});

gif.on('progress', p => {
if (!isRendering) return;
// GIF rendering progress (0 to 1) - map to 50-100% of the bar
const percent = Math.round(50 + (p * 50));
progressFill.style.width = `${percent}%`;
progressFill.textContent = `${percent}%`;
progressInfo.textContent = `Rendering GIF: ${Math.round(p * 100)}%`;
});

gif.on('finished', blob => {
if (!isRendering) return; // Check if cancelled during final stage
progressInfo.textContent = 'GIF Animation complete!';
progressFill.style.width = '100%';
progressFill.textContent = '100%';

const url = URL.createObjectURL(blob);
previewImage.src = url;
previewImage.dataset.blobUrl = url; // Store for download
previewImage.dataset.format = 'gif';
previewDiv.style.display = 'block';

resetUIState();
});
}

function resetUIState() {
// Restore renderer size and aspect ratio
const originalSize = new THREE.Vector2();
renderer.getSize(originalSize);
if(originalSize.x !== window.innerWidth || originalSize.y !== window.innerHeight) {
onWindowResize(); // This resets to current window size
}


// Re-enable buttons and controls
renderBtn.disabled = false;
previewBtn.disabled = false;
controlsPanel.style.opacity = 1.0;
isRendering = false;

// Reset rotation to initial state if desired
setMeshRotation(0);
}


function closePreview() {
previewDiv.style.display = 'none';
// Optional: Revoke object URL to free memory if download isn't needed anymore
const url = previewImage.dataset.blobUrl;
if (url) {
// URL.revokeObjectURL(url); // Be cautious: revoking prevents further downloads
// previewImage.dataset.blobUrl = '';
// previewImage.src = '';
}
}

function downloadAnimation() {
const url = previewImage.dataset.blobUrl;
const format = previewImage.dataset.format || 'gif';

if (!url) {
alert("No animation preview available to download.");
return;
}

const a = document.createElement('a');
a.href = url;
a.download = `wireframe-animation.${format}`;
document.body.appendChild(a); // Required for Firefox
a.click();
document.body.removeChild(a);
// Don't revoke URL immediately after click, allow download to start
}

// --- Initialize ---
window.onload = initScene;

</script>
</body>
</html>